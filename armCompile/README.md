# ARM64 ABI & Stack Backtrace Learning

此目录包含关于 ARM64 汇编调用约定 (ABI) 和手动回溯调用栈 (Backtrace) 的学习代码和说明。

## 1. ARM64 调用约定 (AAPCS64)

在 ARM64 架构下，函数调用遵循 AAPCS64 标准。

### 参数传递
*   **整数/指针参数**: 前 8 个参数通过寄存器 `x0` - `x7` 传递。
*   **浮点参数**: 前 8 个浮点参数通过寄存器 `v0` - `v7` (或 `s0`-`s7`, `d0`-`d7`) 传递。
*   **栈传递**: 超过上述数量的参数，会通过栈 (Stack) 传递。参数入栈顺序是从右向左 (Right-to-Left)，即第 N 个参数先入栈 (高地址)，第 9 个参数最后入栈 (低地址)。

### 返回值
*   **整数**: 存储在 `x0`。
*   **浮点**: 存储在 `v0`。

### 关键寄存器
*   **SP (Stack Pointer)**: 栈指针，指向栈顶 (低地址)。
*   **LR (x30)**: 链接寄存器，保存函数返回地址。
*   **FP (x29)**: 帧指针，通常保存上一个栈帧的 FP。
*   **x19-x28**: Callee-saved (被调用者保存) 寄存器，函数如果不使用则不动，使用则必须先保存再恢复。
*   **x9-x15**: Caller-saved (调用者保存) 临时寄存器。

示例代码: `src/abi_test.cpp`

---

## 2. 栈帧结构与手动回溯 (Backtrace)

ARM64 的标准栈帧结构使得手动回溯调用栈变得相对简单。核心在于 `FP (x29)` 寄存器形成了一个链表。

### 栈帧布局 (Stack Frame Layout)
典型的栈帧结构 (由高地址向低地址增长):

```text
+------------------+  <-- 上一个 FP (Caller's FP)
|  Prev LR (x30)   |  [FP + 8]   (Caller 的返回地址)
+------------------+
|  Prev FP (x29)   |  [FP]       (指向 Caller 的栈帧起始)
+------------------+  <-- 当前 FP (Current Frame Pointer)
|                  |
|   Local Vars     |
|                  |
+------------------+  <-- SP (Stack Pointer)
```

### 回溯原理
1.  **获取当前 FP**: 读取 `x29` 寄存器或使用 `__builtin_frame_address(0)`。
2.  **获取 LR**: `*(FP + 8 bytes)` 即为当前函数的返回地址 (Return Address)，也就是调用者代码执行到的位置。
3.  **获取上级 FP**: `*FP` 即为上一个栈帧的 FP。
4.  **循环**: 重复步骤 2 和 3，直到 FP 为 0 或非法地址。

示例代码: `src/backtrace_test.cpp` (包含手动回溯的实现)
